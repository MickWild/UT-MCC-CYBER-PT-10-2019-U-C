# Malware Analysis

## Malware Analysis Enviroment

Before you can run malware, you need to have a safe enviroment setup. If you run fresh malware on a production system, you could be in for a massive headache. Thus, malware should be conducted on air gapped networks. These are isolated networks with machines that are disconnected from the Internet or any other networks to prevent the malware from spreading.


## Virtual Box Setup

https://github.com/the-Coding-Boot-Camp-at-UT/UT-MCB-CYBER-PT-07-2019-U-C/tree/master/Week%207%20-%20Malware%20Analysis/Day1-Malware_Analysis/Activities/VM_Setup  

### Enable Drag and Drop
1. With the VM up, select **Devices** and then **Drag and Drop** and then **Bidirectional**. 

2. Reboot your VM. 

### VM Snapshot

1. From Virtual Box, make sure your Windows 10 VM is selected and then in the upper right corner select **Machine Tools** and then **Snapshots**

2. Click on **Take** and then give your snapshot a name (like **Pre-Malware**) and short description.
  - **Note:** We take the snapshot now while we still have things like AV and the NIC enabled. 

## Malware Download

1. Download the **trickster.zip** file into your VM enviroment, and save it to your Desktop. The password for the file is `malware123`
  - https://drive.google.com/file/d/19I8ifzTiR_uvNySEyspHTHHtOv1WmOod/view?usp=sharing or https://tinyurl.com/to9olud
  - You you enabled drag and drop you can move it do the desktop of your VM. 

## Change Host and other Settings
1. From the settings of the VM change the network adapter to **Host-only Adapter**. This will prevent the VM from communicating with any enviroment outside of its own VM. 

2. If you haven't changed it already, adjust your Video memory to 21 MB. 

3. Next, Turn off **Windows Defender Firewall** by searching for **Defender** and selecting **Windows Defender Firewall**. Once here, click on **Turn Windows Defender Firewall on or off** from the left hand menu and select **No** under both *Private network settigns* and *Public network settings* then click **Ok**.

4. NOTE: If this was a VM owned by our organization, we could also turn off Virus & Threat protection. But we can't since this is technically a Microsoft owned VM.

5. Let's take another snapshot while we're here. 

## Static Malware Analysis

- Static analysis describes the process of analyzing the code or structure of a program to determine its function. The program itself is not run at this time. In contrast, when performing dynamic analysis, the analyst actually runs the program.

### Antivirus Scanning

- When first analyzing prospective malware, a good first step is to run it through multiple antivirus programs, which may already have identified it. 

- But antivirus tools are certainly not perfect. They rely mainly on a database of identifiable pieces of known suspicious code (file signatures), as well as behavioral and pattern-matching analysis (heuristics) to identify suspect files. 

- One problem is that malware writers can easily modify their code, thereby changing their program’s signature and evading virus scanners. Also, rare malware often goes undetected by antivirus software because it’s simply not in the database. Finally, heuristics, while often successful in identifying unknown malicious code, can be bypassed by new and unique malware.

- Because the various antivirus programs use different signatures and heuristics, it’s useful to run several different antivirus programs against the same piece of suspected malware. Websites such as VirusTotal (http://www.virustotal.com/) allow you to upload a file for scanning by multiple antivirus engines. 

- This is when you would use bash or terminal to create a hash of the potential malware. We've done this in earlier classes. Creating a MD5 or a SHA-1 hash and uploading it to Virus Total is a great way to do this. 

### Finding Strings

- A string in a program is a sequence of characters such as “the.” A program contains strings if it prints a message, connects to a URL, or copies a file to a specific location. What we want to do is pull out any ASCII strings inside that binary. 

- Searching through the strings can be a simple way to get hints about the functionality of a program. For example, if the program accesses a URL, then you will see the URL accessed stored as a string in the program. You can use the Strings program (http://bit.ly/ic4plL), to search an executable for strings, which are typically stored in either ASCII or Unicode format. For today's exercise, we'll be using **Floss**. 

- Walk the students through this activity [Static Analysis with Floss](Activities/Static_Analysis/README.md)
- 
### PE File Headers and Sections
- PE file headers can provide considerably more information than just imports. The PE file format contains a header followed by a series of sections. The header contains metadata about the file itself. 

-  We can use the PEview tool to browse through the information. Note the **IMAGE_FILE_HEADER** entry. The Time Date Stamp Sections description at tells us when this executable was compiled, which can be very
useful in malware analysis and incident response. For example, an old compile time suggests that this is an older attack, and antivirus programs might contain signatures for the malware. A new compile time suggests the reverse.

- However, a competent malware writer can easily fake the compile time. If you see a compile time that makes no sense, it probably was faked.

- The **IMAGE_OPTIONAL_HEADER** section includes several important pieces of information. The Subsystem description indicates whether this is a console or GUI program. Console programs have the value **IMAGE_SUBSYSTEM_WINDOWS_CUI** and run inside a command window. GUI programs have the value **IMAGE_SUBSYSTEM_WINDOWS_GUI** and run within the Windows system. Less common subsystems such as Native or Xbox also are used.

- The most interesting information comes from the section headers, which are in **IMAGE_SECTION_HEADER**. These headers are used to describe each section of a PE file. The compiler generally creates and names
the sections of an executable, and the user has little control over these names. As a result, the sections are usually consistent from executable to executable and any deviations may be suspicious.

-  Virtual Size at tells us how much space is allocated for a section during the loading process. The Size of Raw Data at shows how big the section is on disk. These two values should usually be equal, because data should take up just as much space on the disk as it does in memory. Small differences are normal, and are due to differences between alignment in memory and on disk.

- The section sizes can be useful in detecting packed executables. For example, if the Virtual Size is much larger than the Size of Raw Data, you know that the section takes up more space in memory than it does on disk. This is often indicative of packed code, particularly if the .text section is larger in memory than on disk. 

- 



## Dynamic Analysis with Autoruns
Static analysis proved that the trickster.exe was encrypted, and was not able to provide us any 'smoking guns' to see if it is indeed malware. So now we have to execute it.

We're goign to try to figure out what the malware does to the system, does it call the registry, does it reach out to the Internet, does it modify files, download files, etc.

The first step in dynamic analysis is having a good baseline of your system, and this is different than the Snapshot. We want to know what the registry looks like, DLL files, etc. We can use a program called **Autoruns** to do this for us. Type `autoruns` in a command prompt to bring it up. 
  - **Note** if yours did not install as part of Flare VM, you can download it here: https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns 

- From within Autoruns, click on **File**, and then **Run as Administrator**. This will let Autoruns have full access to the system, not just what the user account is interacting with. Let it run for about 30 seconds. When it is done, it will say **Ready** in the bottom left corner of the Autoruns window. This is your baseline, so click on **File** and then **Save**. Save it to the Desktop and call it something like **Baseline**. 

- Now, run trickster.exe as an Administrator. Give it a few seconds to run, and then go back to the Autoruns window and click on the **Refresh** button. Now you have an Autoruns file with a potentially mallicious program interacting with the operating system.

- Let's compare our basline to what we just captured. Click on **File** and then **Compare** and then navigate to your baseline you saved on the Desktop. This will show us what is "new". 
  - Trickster added a **Task Scheduler** and put an executable there, **usjdltufs.exe**. 

## Scheduled Tasks
Now we have to investigate **Windows Task Scheduler** to see what got added after executing trickster.exe. 

- From the Start menu search for **Task Scheduler** and open it up.

- From the main window, if we scroll down to **Active Tasks** we can see the newly added task **servies update**. Double click on it and investigate it. 
  - Look at the Actions tab. And upon further analysis, we see that this program is run in the background. We can't get much info, so we need to use some other tools to see what is going on.


## Wireshark and Process Monitoring
For our next step, we want to be able to confirm that this .exe is a beacon, probably checking into a C2C server. To do this, we need a pristine VM from which to work.

- Shut down your VM, click on **Snapshots** and then click on your **New Install**, and then **Restore**. You don't need to keep a copy of the current snapshot. For this instance, go ahead and leave the Network settings to **NAT** and then start up your VM.

- You'll remember that this state has Windows Defender and Firewall still running. You'll want to disable them.  

- Use 7Zip to unzip trickster.zip to the desktop: `malware123` is the password.

- Next, start up **Process Monitor** by search for **procmon** in the Windows start menu. 
  - https://docs.microsoft.com/en-us/sysinternals/downloads/procmon

- Once Process Monitor starts up, you can click on the little **magnifying glass** on the toolbar to stop the capture. Then, apply a Filter by clicking on **Filter** and then **Filter**. CLick the Drop down to select **Process Name** and then put **usjdltufs.exe** in the empty box, and then click on **Add** and then **Ok**. 

- Now, open up **WireShark**, start a capture, and then execute **trickster.exe** as administrator with both Process Monitor and Wireshark running (don't forget to re-enable Process Monitor captureing by clicking on the magnifying glass.) 

- To correspond the Time entries in Process Monitor with the time entries in Wireshark we need, in Wireshark, to go to **View, Time Display Format, Time of Day**

- To clear stuff up, let's turn off **Registry** activity and **File** activity in Process Monitor, leaving us with **Network** and **Process and Thread** activity. Let the logging tools run for about 4-5 mins.

- Correlating times between Process Monitor and Wireshark, we should see a DNS callout to `api.ipify.org` and once that response comes back, we see our machine talking to an IP via port 80. 

- Apply some basic filters to Wireshark, such as `udp.port == 53` to look for DNS traffic and `tcp.port == 80`

- Find the HTTP Get request, and then check the TCP Stream. You should see a return IP. This piece of "training malware" is checking into `checkip.amazonaws.com` and requesting for it's public IP, mimicing a C2C server.

- If we leave this running for several minutes, we'll see that it calls out to several IP addresses, trying to communicate with a C2 server that's not blocked. It's probably tryign to get/download **Stage 2** of the malware.

## Files and Folders Created

Navigate to the location of the u.exe, in `C:\Users\IEUser\AppData\Roamin\winapp\`

When we look here, we see a folder called Modules. This is empty, but if the malware had been able to call out to a C2 Server it could have mroe information in there. There are two other files, though. Let's open them with **Notepad**.

- Open up **client_id**  with Notepad. The stuff to the left of the udnerscore is the host name. Everything to the right is the unique identifier. This Malware will try to connect to a Botnet, and this will identify which machine it is. If this is Ransom Ware, this is the unique ID that's use to determine if you've paid or not. 

- Open up **group_tag** this is just an alphanumeric code indicitating what group your machine is part of. If someone was going to "rent" or "sell" a group of machines that are part of a Botnet to conduct something like a DDOS attack, this would indicate that group. 

## Indicators of Compromise

You can follow the breadcrumbs on and on, but at some point you need to make the determination on if the software was mallicious or not. This is where we need to examine our indicators of compromise

  - The file hash for trickster.exe
  - The fact that trickster.exe creates another .exe when it's executed, and it creates some files and folders on the computer in a sneaky way
  - It creates a client id and group tag and modules folder. 

So, right now we know this is a Stage 1 droper, beaconing out to a C2 server trying to get instructions.

## Static Analysis with Ida and Ollydbg
We're going to do some more static analysis by looking at the code using a program called Ida. Ida is a decompiler. Navigate to **Desktop, FLARE, Disassemblers** and then Open up **idafree**. 

- With Ida open, click on **New** and then **PE Executable** 

- Once the window is open, put the **usjdltufs.exe** into Ida.

- On the left side of the window, Ida is attempting to provide us the Assembly Code for the program.

- Click on the **Exports** tab and then the **Imports** tab. On the **Imports** tab it shows us all of the different processes and functions that are called by this program. We can see that it opens, closes, and queries registry keys (we also saw this in process monitor). It can also Create Files or find out what directory its sitting in. It can get command line arguments and run its own commands, load strings, register classes, etc. Now, this is helpful information for some, especially if you're trying to do an entire reverse engineer of the malware, but that's beyond the scope of what we're trying to show. So, unless you understand Assembly Language, there isn't too much that's helpful here. So let's see what else we can find out. 

- We're gonna run the program through a debugger, and what that allows us to do is see what the malware is doing step by step by step. One instruction at a time, as it goes through. 

- Open up **Desktop, FLARE, Debuggers, Ollydbg** (Olly-de-bug). Go ahead and click **Yes** on the prompts that come up.

- Now, open up the file in `C:\Users\IEUser\AppData\Roamin\winapp\usjdltufs.exe`

- Here, we also see more assembly language. 

- It's important to note that a lot of malware will protect itself and prevent it from being run step-by-step in something like a decompiler. We can hit the **Play** button to try to play this malware step-by-step. Let's see what happens.

- It looks like this malware might be able to determine that it's being run in something like a decompiler, because it didn't do anything when we ran it. Let's see if we can still dig further. We're going to have to do a litle more complex method as part of our analysis. Let's do that now. 

## Process Dump
Thus far, we've been able to determine that the malware appears to be encrypted (when we ran Floss) and when running through a debugger it's stopping instantly. So now, we have to run the process and capture it in memory while it is being unpacked and then analyze it. But, to do that, we need to start with a clean VM again. 

- Once you have your clean VM, open up your browser and navigate to http://split-code.com/processdump.html and then downl the **Process Dump** program and extract the **p65.exe** to the Desktop. 

- Next, open up a **Command Prompt** as **Administrator** and then navigate to the Desktop at `c:\Users\IEUser\Desktop\pd_latest`. Next, create a hashed database of all the processes currently running before running any malware by typing this on the command line `pd64.exe -db gen`
  - This will find all of the processes running on the system, capture them, and then create a hash value for all of those processes. This can take 5-10 minutes to complete, depending on how fast your system is.

- Once the database generation is done, you should see a new file on your Desktop called **clean.hashes**. Now we have to execute the malware with `pd64.exe -p trickster.exe` **BUT DON'T HIT ENTER YET**. Before you hit enter, right-click on **trickster.exe** on your Desktop and **Run as Administrator**. As soon as you start it, then hit **Enter** on your command on the command line. Once it's done, we should have another file on the Desktop. This is that piece of malware, unpacked, straight from memory.

- Open up IDAfree again. Now, click and drag that new .exe and drop it into IDA. Now, we should have the dumped file from memory and look to see if there's anything of interest in it. This should be a little more fruitful than the last time we looked at it in IDA.

Look at your Imports one more time, and note there are new ones: **Sleep** and **GetTickCount**. 
  - GetTickCount counts the processes on the machine. 
  - **Sleep** we should double click on. Upon investigation, we see that it waits 5 seconds to let the program launch (**push 1388**), then create the file and folder before copying to the hard drive and then running usjdltufx.ese

- It starts, waits, creates the folder, waits, runs the program, then waits. It does this this way as a way to detect if things are ready for the next step. 

- If we scroll down, you can see all of the things this piece of malware does. We're not going to go into it any futher, but this is an example of how to take a capture of malware from memory and looking at some of the tools you can use to reverse engineer it.

- 


